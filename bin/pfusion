#!/usr/bin/env perl
# TODO: RCL 2011-09-09 Intro header
#
use strict;
use warnings;
use YAML qw/LoadFile DumpFile Dump/;
use Net::OAuth2::Client 0.09;
use Getopt::Long;
use File::Spec::Functions qw/catfile/;
use Google::Fusion;
use Term::ReadLine;
use File::HomeDir;
use Carp;
use Try::Tiny;
use Time::HiRes qw/time/;

my %params;
GetOptions( \%params,
    'client_id=s',
    'client_secret=s',
    'access_code=s',
    'refresh_token=s',
    'access_token=s',
    'config=s',
    );

# Clean out any undefined values
%params = map{ $_ => $params{$_} }
    grep{ $params{$_} }
    keys %params;

# See if there's a config file in the users home, or a config file defined
my $conf_file = $params{config} || catfile( File::HomeDir->my_home() , '.fusion' );
delete( $params{config} );
if( -f $conf_file ){
    printf "Trying to load config from %s\n", $conf_file;
    my $file_params = LoadFile( $conf_file );
    %params = (
        %{ $file_params },
        %params,
        );
}

# Initialise the Fusion object and force the auth_client to be built to see
# if enough parameters were given (it's lazy by default)
my $fusion = undef;
try{
    $fusion = Google::Fusion->new( %params );
    $fusion->auth_client();
}catch{
    print $_;
    # TODO: RCL 2011-09-09 Make poddoc
    print "Help to come here...\n";
    exit;
};

# Set up the terminal readline controller
my $term = Term::ReadLine->new('Fusion');
my $prompt = "fusion> ";
my $OUT = $term->OUT || \*STDOUT;
binmode $OUT, ':utf8';
my $command = '';

# Now loop handling the commands
COMMAND:
while ( defined ( $command = $term->readline( $prompt ) ) ) {
    warn $@ if $@;
    if( $command =~ m/^\s*$/ ){
        next COMMAND;
    }
    $term->addhistory($command); 
    if( $command =~ m/^\.(.*)$/ or $command =~ m/^(help)$/i ){
        if( not local_command( $1 ) ){
            last COMMAND;
        }
    }else{
        # Time the query
        my $query_start = time(); # 
        my @rows = $fusion->query( $command );
        my $query_time = time - $query_start;

        # Print the result
        my $num_rows = scalar( @rows ) - ( $fusion->headers ? 1 : 0 );
        print_rows( $OUT, \@rows );
        printf "%s line%s in %0.5fs\n",
            $num_rows,
            ( $num_rows > 1 ? 's' : '' ),
            $query_time;
    }
}
# If exit was with [ctrl]-d, then there will be no last command, so add a newline.
printf "%sExiting fusion.\n", ( $command ? '' : "\n" );
exit( 0 );

# Accepts a filehandle and a reference to an array of array references
sub print_rows {
    my $fh = shift;
    my $rows = shift;
    if( scalar( @{ $rows } ) == 0 ){
        return;
    }

    my $columns = scalar( @{ $rows->[0] } );

    # Find the largest element in each row
    # TODO: RCL 2011-09-09 This won't handle elements with newlines gracefully...
    my %max;
    foreach my $row( @{ $rows } ){
        foreach( 0 .. $columns - 1 ){
            if( not $max{$_} or $max{$_} < length( $row->[$_] ) ){
                $max{$_} = ( $row->[$_] ? length( $row->[$_] ) : 0 );
            }
        }
    }
    
    my $fmt = ' | ';
    foreach( 0 .. $columns - 1 ){
        # TODO: RCL 2011-09-08 Add some handling here so that if recognized that all elements of
        # a column are numbers they be right justified
        $fmt .= '%-' . $max{$_} . 's | ';
    }
    $fmt .= "\n";

    foreach my $rownum( 0 .. scalar( @{ $rows } ) - 1 ){
        my $row = $rows->[$rownum];
        #my @cleaned_row;
        #foreach( 0 .. $columns - 1 ){
        #    push( @cleaned_row, $row->[$_] || '' );
        #}
        #printf $fh $fmt, @cleaned_row;
        printf $fh $fmt, @{ $row };

        # print out a separator for the header
        if( $rownum == 0 ){
            # TODO: RCL 2011-09-08 Just print a line of '-'
            printf $fh $fmt, map{ '=' x $max{$_} } 0 .. $columns - 1;
        }
    }
}

# Handle local commands (stuff which is not sent to the Fusion server
sub local_command {
    my $command = shift;
    if( $command =~ m/^(exit|quit)$/i ){
        return 0;
    }elsif( $command =~ m/^help$/i ){
        print_local_help();
    }else{
        print "I don't know how to do that...\n";
    }
    return 1;
}

# The user called the local help command... give them some help baby!
sub print_local_help {
    my %commands = (
        help    => 'show the internal commands',
        quit    => 'exit the application',
        'exit'  => 'exit the application',
        );
    # All local commands start with a '.'
    foreach( sort keys %commands ){
        printf ".%-10s %s\n", $_, $commands{$_};
    }
}
